# -*- coding: utf-8 -*-
"""DBSCAN_Kernel_for_OCSVM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W_e_oBD_P2UHa4weBwtApOSEjYgvPkwt

# Objectives
- Density Based Clustering method as kernal function in One-Class SVM
- Use density based clustering as kernel function for ocsvm
- enhance classifier ocsvm

Import and Install Necessary Libraries
"""

!pip install numpy
!pip install scipy

# Importing Library tools to Our Workspace
import numpy as np
from scipy.optimize import newton

"""### ***A Defination of global variables is Made Below***
We Use higher precision data types to Avoid Precision Issues when Setting Up the Main Relaxation loop
"""

precision = np.float128

# Define global variables
alpha = precision(0.5)
delta = precision(0.05)
rho = precision(0.02)
nPop = precision(0.0185)
gx = precision(0.00)
theta = precision(2.0)
ig = precision(0.0)

# Defination of the number of variables
n1 = 2
n = 3
n3 = 0
M = 200
N = n + n3

"""***Implementing Steady State Values...***"""

# Steady state values
u1ss = ((delta + rho + gx * theta) / alpha) ** (1 / (alpha - 1))
u2ss = u1ss ** alpha - (nPop + delta + gx) * u1ss
u3ss = 0

# Initial boundary conditions
u1_ini = 0.9 * u1ss
u3_ini = 0.163

"""**We Create An Array to Store State Variables;**"""

# Create an array to store the state variables
state_vars = np.ones(N, dtype=precision)
state_vars[0] = 0.1  # Initial value of capital is at 10% of its steady state value
state_vars[1] = 0.5

# Define the system of ordinary differential equations
def funcODE(u1, u2, u3):
    dudt = [
        u1 ** alpha - u2 - (nPop + delta + gx) * u1,
        -nPop * u3,
        u2 * (alpha * u1 ** (alpha - 1) - (delta + rho + gx * theta)) / theta
    ]
    return dudt

# Define the function to calculate the final boundary conditions
def funcfinal(u1, u3):
    return [u3 - u3ss]

# Define the function to calculate the initial boundary conditions
def funcINI(u1, u3):
    return [u1_ini - u1, u3_ini - u3]

"""***Defining and Configuring the Relaxation Algorithm...***"""

# Relaxation algorithm settings
tol = 1e-9
maxit = 100
nu = 0.01
damp = 1
dampfac = 2

# Initialize relaxation algorithm
y = np.ones(N)
y[0] = u1_ini
y[1] = u3_ini
y[2] = u2ss

"""Next, We Create a Function that Solves ODE's with Newton's Method"""

# Function for solving the ODEs with Newton's method
def solveODEWithNewton(y):
    def residuals(y_new):
        return np.array(funcODE(y_new[0], y_new[2], y_new[1]) - y)

    y_solution = newton(residuals, y, tol=tol, maxiter=maxit)
    return y_solution

# Main relaxation loop
for _ in range(maxit):
    y_new = solveODEWithNewton(y)
    y = y_new

"""***Accessing The Major Variables:...***"""

# final values as:
u1_final = y[0]
u2_final = y[2]
u3_final = y[1]